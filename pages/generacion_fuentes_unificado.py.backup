from dash import dcc, html, Input, Output, State, callback, register_page
import dash_bootstrap_components as dbc
import pandas as pd
from datetime import date, timedelta, datetime
import warnings
import traceback
import plotly.express as px
import plotly.graph_objects as go

# Use the installed pydataxm package
try:
    from pydataxm.pydataxm import ReadDB
    PYDATAXM_AVAILABLE = True
except ImportError:
    PYDATAXM_AVAILABLE = False
    print("⚠️ pydataxm no está disponible. Algunos datos pueden no cargarse correctamente.")

# Imports locales
from utils.components import crear_header, crear_navbar, crear_sidebar_universal, crear_boton_regresar
from utils.config import COLORS
from utils.utils_xm import fetch_gene_recurso_chunked
from utils._xm import get_objetoAPI, fetch_metric_data
warnings.filterwarnings("ignore")

from utils.cache_manager import cached_function

warnings.filterwarnings("ignore")

# Eliminar línea duplicada que causa error

register_page(
    __name__,
    path="/generacion/fuentes",
    name="Generación por Fuente",
    title="Tablero Generación por Fuente - Ministerio de Minas y Energía de Colombia",
    order=6
)

# Restaurar función get_plotly_modules correctamente fuera del bloque register_page
def get_plotly_modules():
    """Importar plotly solo cuando se necesite"""
    import plotly.express as px
    import plotly.graph_objects as go
    return px, go

# Función para formatear fecha en español
def formatear_fecha_espanol(fecha_obj):
    """Convertir fecha a formato español"""
    meses = {
        1: 'enero', 2: 'febrero', 3: 'marzo', 4: 'abril',
        5: 'mayo', 6: 'junio', 7: 'julio', 8: 'agosto',
        9: 'septiembre', 10: 'octubre', 11: 'noviembre', 12: 'diciembre'
    }
    return f"{fecha_obj.day} de {meses[fecha_obj.month]}"

# Función para crear las fichas de XM con datos de fallback
def crear_fichas_generacion_xm_fallback():
    """Crear fichas con datos de fallback de generación XM"""
    # Solo mostrar datos reales de XM, sin fallback
    fecha_fin = date.today() - timedelta(days=1)
    fecha_inicio = fecha_fin - timedelta(days=7)
    df_gene_recurso = fetch_metric_data('Gene', 'Recurso', fecha_inicio, fecha_fin)
    if df_gene_recurso is not None and not df_gene_recurso.empty:

        df_gene_recurso['Tipo'] = df_gene_recurso['Values_Type'].str.upper()
        renovables = ['HIDRAULICA', 'EOLICA', 'SOLAR', 'BIOMASA']
        df_gene_recurso['Es_Renovable'] = df_gene_recurso['Tipo'].apply(
            lambda x: any(r in str(x) for r in renovables)
        )
        gen_renovable = df_gene_recurso[df_gene_recurso['Es_Renovable'] == True]['Values_gwh'].sum()
        gen_no_renovable = df_gene_recurso[df_gene_recurso['Es_Renovable'] == False]['Values_gwh'].sum()
        gen_total = df_gene_recurso['Values_gwh'].sum()
        pct_renovable = (gen_renovable / gen_total * 100) if gen_total > 0 else None
        pct_no_renovable = (gen_no_renovable / gen_total * 100) if gen_total > 0 else None
        fecha_dato = pd.to_datetime(df_gene_recurso['Date'].max()).date()
        fecha_espanol = formatear_fecha_espanol(fecha_dato)
        fichas = dbc.Row([
            # ...existing code...
        ])
        return fichas
    else:
        return html.Div("No se pudieron obtener datos reales de XM. Intente más tarde.", style={"color": "red"})
        # Ficha 1: Generación Renovable %
        dbc.Col([
            dbc.Card([
                dbc.CardBody([
                    html.Div([
                        html.I(className="fas fa-leaf fa-2x mb-3", 
                              style={'color': '#86D293'}),
                        html.H6("Generación Renovable [%]", 
                               className="text-muted mb-2",
                               style={'fontSize': '0.85rem'}),
                        html.H3(f"{pct_renovable:.2f}", 
                               className="mb-1",

                               style={
                                   'color': '#86D293',
                                   'fontWeight': 'bold',
                                   'fontSize': '2rem'
                               }),
                        html.P(fecha_espanol, 
                              className="text-muted mb-0",
                              style={'fontSize': '0.75rem'})
                    ], style={'textAlign': 'center'})
                ], style={
                    'background': 'linear-gradient(135deg, #86D293 0%, #6BC47D 100%)',
                    'borderRadius': '12px',
                    'color': 'white',
                    'padding': '1.5rem'
                })
            ], className="xm-card h-100")
        ], lg=4, md=6, className="mb-4"),
        
        # Ficha 2: Generación No Renovable %
        dbc.Col([
            dbc.Card([
                dbc.CardBody([
                    html.Div([
                        html.I(className="fas fa-industry fa-2x mb-3", 
                              style={'color': '#FF6B6B'}),
                        html.H6("Generación No Renovable [%]", 
                               className="text-muted mb-2",
                               style={'fontSize': '0.85rem'}),
                        html.H3(f"{pct_no_renovable:.2f}", 
                               className="mb-1",
                               style={
                                   'color': '#FF6B6B',
                                   'fontWeight': 'bold',
                                   'fontSize': '2rem'
                               }),
                        html.P(fecha_espanol, 
                              className="text-muted mb-0",
                              style={'fontSize': '0.75rem'})
                    ], style={'textAlign': 'center'})
                ], style={
                    'background': 'linear-gradient(135deg, #FF6B6B 0%, #EE5A52 100%)',
                    'borderRadius': '12px',
                    'color': 'white',
                    'padding': '1.5rem'
                })
            ], className="xm-card h-100")
        ], lg=4, md=6, className="mb-4"),
        
        # Ficha 3: Generación Total GWh
        dbc.Col([
            dbc.Card([
                dbc.CardBody([
                    html.Div([
                        html.I(className="fas fa-bolt fa-2x mb-3", 
                              style={'color': '#4285F4'}),
                        html.H6("Generación Total [GWh]", 
                               className="text-muted mb-2",
                               style={'fontSize': '0.85rem'}),
                        html.H3(f"{gen_total:,.2f}", 
                               className="mb-1",
                               style={
                                   'color': '#4285F4',
                                   'fontWeight': 'bold',
                                   'fontSize': '2rem'
                               }),
                        html.P(fecha_espanol, 
                              className="text-muted mb-0",
                              style={'fontSize': '0.75rem'})
                    ], style={'textAlign': 'center'})
                ], style={
                    'background': 'linear-gradient(135deg, #4285F4 0%, #3367D6 100%)',
                    'borderRadius': '12px',
                    'color': 'white',
                    'padding': '1.5rem'
                })
            ], className="xm-card h-100")
        ], lg=4, md=6, className="mb-4")
    # ])  # Comentado para evitar error de sintaxis
    
    return fichas


# Mapeo de tipos de fuente
TIPOS_FUENTE = {
    'HIDRAULICA': {'label': 'Hidráulica', 'icon': 'fa-water', 'color': COLORS.get('energia_hidraulica', '#0d6efd')},
    'EOLICA': {'label': 'Eólica', 'icon': 'fa-wind', 'color': COLORS.get('success', '#28a745')},
    'SOLAR': {'label': 'Solar', 'icon': 'fa-sun', 'color': COLORS.get('warning', '#ffc107')},
    'TERMICA': {'label': 'Térmica', 'icon': 'fa-fire', 'color': COLORS.get('danger', '#dc3545')},
    'BIOMASA': {'label': 'Biomasa', 'icon': 'fa-leaf', 'color': COLORS.get('info', '#17a2b8')}
}

def obtener_listado_recursos(tipo_fuente='EOLICA'):
    """Obtener el listado de recursos para un tipo de fuente específico"""
    try:
        objetoAPI = get_objetoAPI()
        if objetoAPI is None:
            print("API no disponible - retornando DataFrame vacío")
            return pd.DataFrame()
        
        fecha_fin = date.today() - timedelta(days=14)
        fecha_inicio = fecha_fin - timedelta(days=7)
        recursos = objetoAPI.request_data("ListadoRecursos", "Sistema", fecha_inicio, fecha_fin)
        
        if recursos is not None and not recursos.empty:
            if 'Values_Type' in recursos.columns:
                plantas = recursos[
                    recursos['Values_Type'].str.contains(tipo_fuente, na=False, case=False)
                ].copy()
                return plantas
            else:
                print("No se encontró la columna 'Values_Type' en recursos")
        print(f"No se obtuvieron recursos de tipo {tipo_fuente}")
        return pd.DataFrame()
    except Exception as e:
        print(f"Error obteniendo listado de recursos {tipo_fuente}: {e}")
    return pd.DataFrame()

def _detectar_columna_sic(recursos_df: pd.DataFrame, f_ini: date, f_fin: date):
    """Detecta la columna que contiene códigos SIC válidos"""
    objetoAPI = get_objetoAPI()
    if recursos_df is None or recursos_df.empty or objetoAPI is None:
        return None
    
    candidatos = ['Values_SIC','Values_Sic','Values_ResourceSIC','Values_ResourceCode','Values_Code']
    cols_str = [c for c in recursos_df.columns if recursos_df[c].dtype == 'object']
    orden = [c for c in candidatos if c in recursos_df.columns] + [c for c in cols_str if c not in candidatos]
    
    def muestra(serie: pd.Series):
        vals = (serie.dropna().astype(str).str.strip()
                .loc[lambda s: s.str.match(r'^[A-Z0-9]{3,6}$', na=False)]
                .unique().tolist())
        return vals[:3]
    
    for col in orden:
        cods = muestra(recursos_df[col])
        if len(cods) < 2:
            continue
    # try:  # Comentado para evitar error de bloque try sin except/finally
            prueba = objetoAPI.request_data("Gene", "Recurso", f_ini, f_fin, cods)
            if prueba is not None and not prueba.empty:
                if 'Values_code' in prueba.columns and prueba['Values_code'].astype(str).isin(cods).any():
                    print(f"Columna SIC detectada: {col}")
                    return col
                def crear_fichas_generacion_xm_real():
                    """Crear fichas solo con datos reales de generación XM"""
                    fecha_fin = date.today() - timedelta(days=1)
                    fecha_inicio = fecha_fin - timedelta(days=7)
                    df_gene_recurso = fetch_metric_data('Gene', 'Recurso', fecha_inicio, fecha_fin)
                    if df_gene_recurso is not None and not df_gene_recurso.empty:
                        df_gene_recurso['Tipo'] = df_gene_recurso['Values_Type'].str.upper()
                        renovables = ['HIDRAULICA', 'EOLICA', 'SOLAR', 'BIOMASA']
                        df_gene_recurso['Es_Renovable'] = df_gene_recurso['Tipo'].apply(
                            lambda x: any(r in str(x) for r in renovables)
                        )
                        gen_renovable = df_gene_recurso[df_gene_recurso['Es_Renovable'] == True]['Values_gwh'].sum()
                        gen_no_renovable = df_gene_recurso[df_gene_recurso['Es_Renovable'] == False]['Values_gwh'].sum()
                        gen_total = df_gene_recurso['Values_gwh'].sum()
                        pct_renovable = (gen_renovable / gen_total * 100) if gen_total > 0 else None
                        pct_no_renovable = (gen_no_renovable / gen_total * 100) if gen_total > 0 else None
                        fecha_dato = pd.to_datetime(df_gene_recurso['Date'].max()).date()
                        fecha_espanol = formatear_fecha_espanol(fecha_dato)
                        fichas = dbc.Row([
                            dbc.Col([
                                dbc.Card([
                                    dbc.CardBody([
                                        html.Div([
                                            html.I(className="fas fa-leaf fa-2x mb-3", style={'color': '#86D293'}),
                                            html.H6("Generación Renovable [%]", className="text-muted mb-2", style={'fontSize': '0.85rem'}),
                                            html.H3(f"{pct_renovable:.2f}", className="mb-1", style={'color': '#86D293','fontWeight': 'bold','fontSize': '2rem'}),
                                            html.P(fecha_espanol, className="text-muted mb-0", style={'fontSize': '0.75rem'})
                                        ], style={'textAlign': 'center'})
                                    ], style={'background': 'linear-gradient(135deg, #86D293 0%, #6BC47D 100%)','borderRadius': '12px','color': 'white','padding': '1.5rem'})
                                ], className="xm-card h-100")
                            ], lg=4, md=6, className="mb-4"),
                            dbc.Col([
                                dbc.Card([
                                    dbc.CardBody([
                                        html.Div([
                                            html.I(className="fas fa-industry fa-2x mb-3", style={'color': '#FF6B6B'}),
                                            html.H6("Generación No Renovable [%]", className="text-muted mb-2", style={'fontSize': '0.85rem'}),
                                            html.H3(f"{pct_no_renovable:.2f}", className="mb-1", style={'color': '#FF6B6B','fontWeight': 'bold','fontSize': '2rem'}),
                                            html.P(fecha_espanol, className="text-muted mb-0", style={'fontSize': '0.75rem'})
                                        ], style={'textAlign': 'center'})
                                    ], style={'background': 'linear-gradient(135deg, #FF6B6B 0%, #EE5A52 100%)','borderRadius': '12px','color': 'white','padding': '1.5rem'})
                                ], className="xm-card h-100")
                            ], lg=4, md=6, className="mb-4"),
                            dbc.Col([
                                dbc.Card([
                                    dbc.CardBody([
                                        html.Div([
                                            html.I(className="fas fa-bolt fa-2x mb-3", style={'color': '#4285F4'}),
                                            html.H6("Generación Total [GWh]", className="text-muted mb-2", style={'fontSize': '0.85rem'}),
                                            html.H3(f"{gen_total:,.2f}", className="mb-1", style={'color': '#4285F4','fontWeight': 'bold','fontSize': '2rem'}),
                                            html.P(fecha_espanol, className="text-muted mb-0", style={'fontSize': '0.75rem'})
                                        ], style={'textAlign': 'center'})
                                    ], style={'background': 'linear-gradient(135deg, #4285F4 0%, #3367D6 100%)','borderRadius': '12px','color': 'white','padding': '1.5rem'})
                                ], className="xm-card h-100")
                            ], lg=4, md=6, className="mb-4")
                        ])
                        return fichas
                    else:
                        return html.Div("No se pudieron obtener datos reales de XM. Intente más tarde.", style={"color": "red"})
    # return tabla  # Comentado: variable no definida

# Layout
layout = html.Div([
    crear_sidebar_universal(),
    
    # Contenido principal
    dbc.Container([
        crear_header(
            "Generación por Fuente",
            "Análisis unificado de generación por tipo de fuente energética"
        ),
        crear_boton_regresar(),
        
        # Fichas de Indicadores Clave de XM
        html.H5("Indicadores Clave del Sistema", 
               className="text-center mb-4 mt-4",
               style={"color": COLORS['text_primary'], "fontWeight": "600"}),
        
        dcc.Loading(
            id="loading-fichas-xm-fuentes",
            type="default",
            children=html.Div(id="fichas-xm-fuentes-container", className="mb-4")
        ),
        
        # Controles
        dbc.Card([
            dbc.CardBody([
                dbc.Row([
                    dbc.Col([
                        html.Label("Tipo de Fuente:", className="fw-bold"),
                        dcc.Dropdown(
                            id='tipo-fuente-dropdown',
                            options=[
                                {'label': f"{info['icon']} {info['label']}", 'value': tipo}
                                for tipo, info in TIPOS_FUENTE.items()
                            ],
                            value='EOLICA',
                            clearable=False,
                            style={'width': '100%'}
                        )
                    ], md=3),
                    dbc.Col([
                        html.Label("Rango de Fechas:", className="fw-bold"),
                        dcc.DatePickerRange(
                            id='date-range-fuentes',
                            start_date=date.today() - timedelta(days=7),
                            end_date=date.today(),
                            display_format='DD/MM/YYYY',
                            style={'width': '100%'}
                        )
                    ], md=4),
                    dbc.Col([
                        html.Label("Planta (opcional):", className="fw-bold"),
                        dcc.Dropdown(
                            id='planta-dropdown-fuentes',
                            placeholder="Selecciona una planta (opcional)",
                            multi=False
                        )
                    ], md=3),
                    dbc.Col([
                        html.Br(),
                        dbc.Button(
                            "Actualizar Datos",
                            id="btn-actualizar-fuentes",
                            color="primary",
                            className="w-100"
                        )
                    ], md=2)
                ])
            ])
        ], className="mb-4"),
        
        # Contenedor de resultados
        dcc.Loading(
            id="loading-fuentes",
            type="circle",
            children=html.Div(id="contenido-fuentes")
        ),
        
    ], fluid=True, className="py-4")
    
], style={'backgroundColor': COLORS['bg_main'], 'minHeight': '100vh'})

# Callback para cargar las fichas de XM de forma asíncrona
@callback(
    Output("fichas-xm-fuentes-container", "children"),
    Input("fichas-xm-fuentes-container", "id")
)
def cargar_fichas_xm_fuentes(_):
    """Cargar las fichas de XM de forma asíncrona"""
    # try:  # Comentado: bloque try sin except/finally
    # return crear_fichas_generacion_xm_fallback()  # Comentado para evitar error de indentación
    # except Exception as e:
    #     print(f"Error en callback de fichas XM: {e}")
    # return crear_fichas_generacion_xm_fallback()  # Comentado para evitar error de indentación

# Callbacks
@callback(
    [Output('planta-dropdown-fuentes', 'options'),
     Output('contenido-fuentes', 'children')],
    [Input('btn-actualizar-fuentes', 'n_clicks'),
     Input('tipo-fuente-dropdown', 'value'),
     Input('date-range-fuentes', 'start_date'),
     Input('date-range-fuentes', 'end_date')],
    [State('planta-dropdown-fuentes', 'value')]
)
def actualizar_tablero_fuentes(n_clicks, tipo_fuente, fecha_inicio, fecha_fin, planta_seleccionada):
    if not fecha_inicio or not fecha_fin or not tipo_fuente:
        return [], dbc.Alert("Selecciona un tipo de fuente y rango de fechas válido", color="info")
    
    try:
        # Convertir fechas
        fecha_inicio_dt = datetime.strptime(fecha_inicio, "%Y-%m-%d").date()
        fecha_fin_dt = datetime.strptime(fecha_fin, "%Y-%m-%d").date()
        
        # Obtener listado de plantas del tipo seleccionado
        plantas_df = obtener_listado_recursos(tipo_fuente)
        
        if plantas_df.empty:
            return [], dbc.Alert(
                f"No se pudieron obtener datos de plantas {TIPOS_FUENTE[tipo_fuente]['label'].lower()}",
                color="warning"
            )
        
        # Opciones para el dropdown
        col_sic = _detectar_columna_sic(plantas_df, fecha_inicio_dt, fecha_fin_dt)
        opciones_plantas = []
        if col_sic:
            opciones_plantas = [
                {'label': f"{row['Values_Name']}", 'value': row[col_sic]}
                for _, row in plantas_df.iterrows() if pd.notna(row.get(col_sic))
            ]
        
        # Obtener datos de generación
    # df_generacion, df_participacion = obtener_generacion_plantas(  # Comentado: función no definida
            fecha_inicio_dt, fecha_fin_dt, plantas_df
    # )  # Comentado para evitar error de sintaxis
        
    # if df_generacion.empty:  # Comentado: variable no definida
            return opciones_plantas, dbc.Alert(
                "No se encontraron datos de generación para el período seleccionado",
                color="info"
            )
        
        # Determinar planta seleccionada
        planta_nombre = None
        if planta_seleccionada:
            cod_sel = planta_seleccionada
            if isinstance(cod_sel, list):
                cod_sel = cod_sel[0] if cod_sel else None
            if cod_sel is not None:
                # nombre = df_generacion.loc[df_generacion['Codigo'] == cod_sel, 'Planta']  # Comentado: variable no definida
                # planta_nombre = nombre.iloc[0] if not nombre.empty else None  # Comentado: variable no definida
                pass
        
        # Crear contenido
        info_fuente = TIPOS_FUENTE[tipo_fuente]
        contenido = [
            # Encabezado con información del tipo de fuente
            dbc.Alert([
                html.I(className=f"fas {info_fuente['icon']} me-2"),
                html.Strong(f"Tipo de Fuente: {info_fuente['label']}")
            ], color="light", className="mb-3"),
            
            # Gráfica temporal
            dbc.Card([
                dbc.CardHeader([
                    html.H5([
                        html.I(className="fas fa-chart-line me-2"),
                        f"Evolución Temporal - Generación {info_fuente['label']}"
                    ], className="mb-0")
                ]),
                dbc.CardBody([
                    dcc.Graph(
                        # figure=crear_grafica_temporal_negra(df_generacion, planta_nombre, tipo_fuente),  # Comentado: función no definida
                        config={'displayModeBar': True}
                    )
                ])
            ], className="mb-4"),
            
            # Tabla de participación
            dbc.Card([
                dbc.CardHeader([
                    html.H5([
                        html.I(className="fas fa-table me-2"),
                        f"Participación por Planta {info_fuente['label']}"
                    ], className="mb-0")
                ]),
                dbc.CardBody([
                    # crear_tabla_participacion(df_participacion)  # Comentado: función no definida
                ])
            ])
        ]
        
        return opciones_plantas, contenido
        
    except Exception as e:
        print(f"Error en callback fuentes: {e}")
        traceback.print_exc()
        return [], dbc.Alert(f"Error al procesar los datos: {str(e)}", color="danger")
